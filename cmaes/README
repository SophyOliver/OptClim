-------------------------------------------------------------------------------

INTRODUCTION

The package contains a parallel implementation of the Covariance Matrix
Adaption Evolution Strategy (CMAES).
Implemented is the basic strategy with box constraints using C++ and the Eigen
package for matrix calculations.
We follow [1] for the pure CMAES extended by a "boundary handling" as decribed 
in [2]. Both papers are linked on 'The CMA Evolution Strategy' Website [3]

--------------------------------------------------------------------------------

PURPOSE

This version is supposed to optimize the parameters of models that have a long
evaluation time.
It is most suitable, if the model running time is approximately the same
for different parameter vectors.

--------------------------------------------------------------------------------

APPROACH

Optimization is done by chain jobs alternating CMAES optimization steps with
multiple parallel model runs. The number lambda of model runs corresponds to the
number of sampled parameter vectors in each CMAES iteration (population size).
In each iteration, the serial CMAES job is started using "serial.job." It
samples lambda parameter vectors from a probability distribution and writes
them to files called "parameters_i_j.txt" where i is the current iteration
number and j stands for the session number in {1,...,lambda}.
All parallel model evaluations are started using "parallel.job".
Each model run is supposed to read a parameter file and to write the results to
corresponding files called "fitness_i_j.txt".
After termination of the model runs, a new CMAES optimization step is started
reading fitness values from the files, updating probability distributions and
sampling new parameter vectors.
After the i-th iteration, CMAES stores necessary data for the next iteration(s)
in a file "algVars_i.txt" which is read in iteration i+1.
Operational settings and an iteration history is recorded in the file
"nIter.txt", which is accessed by both job files.

--------------------------------------------------------------------------------

USAGE

Generating Executables:
-----------------------

The package consists of the files
- cmaes.cpp		// the main source of the CMAES algorithm
- auxiliaries.cpp/hpp	// some auxiliary functions required by CMAES
- eigenreq.hpp		// path to required EIGEN algebra package and some defs
- testfunctions.cpp	// collection of testfunctions for optimization
- Makefile		// generates executables
- nIter0.dat		// sample interface file (with operational settings)
- serial.job		// serial pbs job file (starting CMAES optimizer)
- parallel.job		// parallel pbs job file (starting parallel model runs)

In order to generate executables, the "Eigen" algebra package, see
  http://eigen.tuxfamily.org
must be available on the system. The Makefile and "eigenreq.hpp" must be adapted
to contain the right path to the Eigen package.
After that, the executables can be generated by typing "make".

Operational settings:
---------------------

Operational parameters must be set in the file "nIter.txt" which will be
accessed by the jobfiles and also serves as iteration history.
The file "nIter0.dat" is a template that can be copied to "nIter.txt".

Currently, also the file "parallel.job" which runs multiple model evaluations
in parallel has to be modified. This concerns lines 5-6 where the walltime, the
number of nodes and the number of processors per node have to be adapted to fit 
the requirements. Also the "aprun" command in line 15 must be adapted to run
the desired model.
The example settings in "/gfs1/work/shmvolki/cmaes/parallel/vChainJobs" are for
"rosenbrock" testfunction of dimension 10 using 200 CMAES iterations with 10
samples per iteration.
An ocean model example using 3 parameters is in "/gfs1/work/shmvolki/model2"
the current nIter0.dat being a template to start 200 CMAES iterations with 10 
parallel model evaluations.

Running Optimization:
---------------------

One optimization is started by typing "msub serial.job".
It is possible to continue a terminated optimization by increasing the
iteration number in nIter.txt and doing "msub serial.job" again.
Also in the case of an iterruption caused by technical problems, optimization
can be continued at the point it has been interrupted.

--------------------------------------------------------------------------------

LITERATURE

[1] N. Hansen (2011). The CMA Evolution Strategy: A Tutorial

[2] N. Hansen, A.S.P. Niederberger, L. Guzzella and P. Koumoutsakos (2009).
    A Method for Handling Uncertainty in Evolutionary Optimization with an
    Application to Feedback Control of Combustion.
    IEEE Transactions on Evolutionary Computation, 13(1), pp. 180-197

[3] CMAES website: https://www.lri.fr/~hansen/cmaesintro.html

--------------------------------------------------------------------------------
